// float精度问题
// 变量和常量
// 逻辑运算符 && || !
// 关系运算符 > < >= <= [==] !=
// 位运算符 ：二进制运算
// if语句 单分子 双分支 多分支
// ?:三目运算符
//// while循环 do while循环
// break continue
#include <stdio.h>
#include <float.h> // float.h头文件中定义了FLT_EPSILON

int main(int argc, char *argv[])
{
    printf("float精度问题\n");
    float f1 = 23400000000;
    f1 = f1 + 10;
    printf("f1 = %f\n", f1);
    // 0-1之间的小数有多少个 无穷多个 32bit 64bit 128bit
    // float/double 精度问题
    // 0.1      0.2        0.3 0.4 0.5 0.6 0.7 0.8 0.9
    //  0.19999999998~0.2000000000001 = 0.2
    printf("f1 = %f\n", FLT_EPSILON); // 1.192093e-07

    printf("变量和常量\n");
    // type variable(变量名、标识符[可以是由逗号隔开的序列]) [= value];
    // 既有定义变量，同时又有初始化变量
    int a;
    a = 10;
    float b = 3.14;
    char c = 'A';
    int d, e = 10;
    // 左值和右值
    // 左值：可以出现在赋值符号左边的值：变量
    // 右值：可以出现在赋值符号右边的值：常量、变量、表达式
    b = a;
    // 常量：不可以被修改的量
    // 1. 字面常量：整数常量、实数常量、字符常量、字符串常量：10, 3.14, 'A', "hello"
    // 2. 符号常量：const type variable = value;
    const int f = 100;
    // 常量用在哪：1. 定义常量 2. 保护变量 3. 优化代码 const double PI = 3.14;

    // 逻辑运算符：&& || !
    // bool: true 1 false 0
    // 逻辑运算符的结果：1 0
    // && 与：两个条件都满足，结果为真      【(条件) && (条件)】    全真为真，有一个为假则为假
    // 1 && 1 = 1
    // 1 && 0 = 0
    // 0 && 1 = 0
    // 0 && 0 = 0
    // || 或：两个条件有一个满足，结果为真  【(条件) || (条件)】    有一个为真则为真，全假为假
    // 1 || 1 = 1
    // 1 || 0 = 1
    // 0 || 1 = 1
    // 0 || 0 = 0
    // ! 非：取反 【!(条件)】 真变假，假变真
    // !1 = 0
    // !0 = 1
    // 逻辑运算符的优先级：! > && > ||
    // 例子：！1 && 0 || 1 && 1
    printf("%d\n", !1 && 0 || 1 && 1);

    // 关系运算符：> < >= <= == != 结果是1 0
    10 > 1; // 1
    // 判断两个数是否相等是用 == 不是 =
    // 判断两个数是否不等是用 !=
    // 逻辑运算符和关系运算符的优先级：! > [> < >= <= == !=] > && > ||

    // 逻辑运算符和关系运算符综合使用
    10 > 1 && 10 < 100;             // 1
    10 > 1 && 10 < 100 || 10 > 100; // 1
    1 && 1 || 0;                    // 1

    // 三目运算符：(条件) ? 表达式1 : 表达式2 三目运算符的结果是表达式1或表达式2，如果条件为真则结果是表达式1，否则结果是表达式2
    int g = 10;
    int h = 20;
    int i = g > h ? g : h; // 取两个数中的最大值
    printf("i = %d\n", i);
    // 单目运算符：++ -- sizeof
    // 二目运算符：+ - * / % = += -= *= /= %=
    // 三目运算符：(条件) ? 表达式1 : 表达式2

    // if语句
    // 情况1：if (条件表达式) {语句}  如果条件为真则执行语句 单分支
    int j = 10;
    if (j > 5)
    {
        printf("j > 5\n");
        printf("j = %d\n", j);
    }

    // 如果if后面只有一条语句，可以省略大括号
    if (j < 5)
        printf("j < 5\n");

    printf("j = %d\n", j); // 这句话不属于if语句

    // 情况2：if (条件表达式) {语句1} else {语句2}  如果条件为真则执行语句1，否则执行语句2 双分支
    j = 10;
    if (j < 5)
    {
        printf("j > 5\n");
        printf("j = %d\n", j);
    }
    else
    {
        printf("j <= 5\n");
    }

    // 情况3：if (条件表达式1) {语句1}
    //       else if (条件表达式2) {语句2} ...
    //       else {语句3}  多分支
    // 1. 从上到下依次判断条件表达式，如果有一个条件表达式为真，则执行对应的语句，然后结束if语句
    // 2. 如果所有的条件表达式都为假，则执行else后面的语句
    // 3. 如果没有else，则不执行任何语句,else是可以省略的
    j = 16;
    if (j < 5)
    {
        printf("j < 5\n");
    }
    else if (j < 10)
    {
        printf("j < 10\n");
        printf("j = %d\n", j);
    }
    else if (j < 15)
    {
        printf("j < 15\n");
    }
    // else
    // {
    //     printf("j >= 15\n");
    // }

    // while循环
    // while (条件表达式) {语句}
    // 1. 先判断条件表达式，如果为真则执行语句，然后再次判断条件表达式
    // 2. 如果条件表达式为假，则结束循环
    // 3. 如果条件表达式一直为真，则一直执行语句
    // 4. 如果条件表达式一开始就为假，则不执行任何语句
    int k = 0;
    while (k < -1)
    {
        printf("k = %d\n", k);
        k++;
    }
    // {}可以省略 但是不建议省略 如果省略了，只能执行一条语句

    // do while循环
    // do {语句} while (条件表达式)
    // 与while循环的区别是do while循环至少执行一次语句
    k = 0;
    do
    {
        printf("k = %d\n", k);
        k++;
    } while (k < -1);

    // break 打断循环 提前[结束] [最近] 的循环
    printf("break\n");
    k = 0;
    while (k < 10)
    {
        k++;
        if (k == 5)
        {
            break;
        }
        printf("k = %d\n", k);
    }

    // continue 跳过本轮循环 继续下一轮循环
    printf("continue\n");
    k = 0;
    while (k < 10)
    {
        k++;
        if (k == 5)
        {
            continue;
        }
        printf("k = %d\n", k);
    }

    return 0;
}