// 作用域: 全局变量 局部变量 //初始化
// 递归函数 // 阶乘 // 斐波那契数列 //递归表达式 递归结束条件
// 输入与输出 stdio.h printf scanf getchar putchar

#include <stdio.h>

int a = 1; // 全局变量：定义在函数外面,整个程序都可以使用

int d; // 全局变量不初始化，里面的值是0
// 局部变量被定义时，编译器不会对其初始化，所以局部变量里面的值是随机的
// 全局变量被定义时，编译器会对其初始化，所以全局变量里面的值是int 0
char e;   // 全局变量不初始化，里面的值是'\0'
float f;  // 全局变量不初始化，里面的值是0.000000
double g; // 全局变量不初始化，里面的值是0.000000
// 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。

int print_a();
int factorial(int n);
int fibonaci(int n);

int main()
{
    printf("第8次课\n");
    // 作用域
    // 全局变量 局部变量
    printf("作用域\n");
    // 全局变量 定义在函数外面的变量，整个程序都可以使用，不仅仅是main函数，print_a函数也可以使用，其他的函数也可以使用，只要在这个文件里面
    print_a();
    // 局部变量 定义在函数里面的变量，只能在定义的函数里面使用，不能在其他函数里面使用
    // printf("b = %d\n", b); 是错误的，b定义在了其他的函数里面

    printf("全局变量的特性\n");
    int c = 3; // 局部变量不初始化，里面的值是随机的
    printf("c = %d\n", c);

    // 递归函数：在函数定义的时候再次调用自己本身这个函数 自己调用自己
    // 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！[故事]是什么呢？
    // "从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！[故事]是什么呢？'
    // 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……'"
    // 递归
    printf("递归函数\n");
    // 10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 3628800
    // 11 ! = 11 * 10! = 11 * 3628800 = 39916800
    // 20! = 20 * 19 * 18 * 17 * 16 * 15 * 14 * 13 * 12 * 11 * 10! = 2432902008176640000
    printf("20! = %d\n", factorial(20));
    // 打印斐波那契数列的前10项 1-10 循环
    // for(变量初始;结束条件;循环变量的变化)
    printf("斐波那契数列的前10项\n");
    for (int i = 1; i <= 10; i++)
    {
        printf("%d ", fibonaci(i));
    }

    // 用循环来做阶乘
    printf("\n用循环来做阶乘\n");
    // 定义一个变量来存储阶乘的结果
    // 循环的次数是n
    // 每一次循环的结果是i（1~n）* 存储阶乘的结果
    int result = 1; // 阶乘的结果
    for (int i = 1; i <= 5; i++)
    {
        result = result * i; // 循环表达式  阶乘的表达式 递归函数里面的递归表达式
    }
    // 1 * 1 * 2 * 3 * 4 * 5 = 120
    printf("5! = %d\n", result);

    // 输入与输出
    // stdio.h = std input output
    // printf 输出 scanf 输入
    // scanf 由两个部分组成：格式字符串 输入变量的地址
    // 输入一个整数
    scanf("%d", &a); // &a 是a的地址
    // scanf 在程序运行的时候，会等待用户输入，用户输入一个整数，然后按回车键，scanf函数才会结束
    printf("a = %d\n", a);
    // 输入多个变量
    int x, y;
    scanf("%d %d\n", &x, &y); //后面的多个变量之间用,隔开
    printf("x = %d, y = %d\n", x, y);
    // 输入一个字符
    // char ch;
    // 回车也是一个字符 \n ASCII码是10
    // scanf("%c", &ch); // 输入一个字符
    // printf("ch = %c\n", ch);
    // getchar() 从键盘输入一个字符
    char ch3 = getchar();
    printf("ch3 = %c\n", ch3);
    // 输出一个字符 putchar()
    putchar(ch3);
    return 0;
}

int print_a()
{
    int b = 2;
    printf("a = %d\n", a);
    printf("b = %d\n", b);
    return 0;
}

// 数的阶乘
// 5! = 5 * 4 * 3 * 2 * 1
// 5! = 5 * 4!
// 4! = 4 * 3!
// 3! = 3 * 2!
// 2! = 2 * 1!
// 1! = 1
// 是不可以定义一个计算阶乘的函数，然后在函数里面调用自己本身，这样就是一个递归函数
// factorial(int); 定义的一个阶乘的函数
// factorial(5);
// factorial(5) = 5 * factorial(4)
// factorial(4) = 4 * factorial(3)
// factorial(3) = 3 * factorial(2)
// factorial(2) = 2 * factorial(1)
// factorial(1) = 1 // 递归的出口，递归的结束条件

// int 的范围是-2147483648到2147483647
// long long 的范围是-9223372036854775808到9223372036854775807
int factorial(int n)
{
    // 递归的出口，递归的结束条件
    // 如果 n = 1，那么返回1
    if (n == 1)
    {
        return 1;
    }
    // 传进来的值是 n
    // 计算n! = n * (n-1)!
    // n! = n * factorial(n-1)
    int result = n * factorial(n - 1);
    return result;
}

// fibonaci数列:前两项是1，从第三项开始，每一项都等于前两项之和
// 1 1 2 3 5 8 13 21 34 55 89 144
int fibonaci(int n)
{
    // 递归的出口，递归的结束条件
    // 如果 n = 1 或者 n = 2，那么返回1
    // 。。。。 。。。 。。。
    if (n == 1 || n == 2)
    {
        return 1;
    }
    return fibonaci(n - 1) + fibonaci(n - 2);
}

// 递归两大部分：递归表达式，递归结束条件
// 递归表达式：递归函数里面调用自己本身
// 递归结束条件：递归的出口，递归的结束条件，必须要有，没有的话，就是死循环

// 递归函数的整体架构
// 1. 递归函数的返回值类型
// 2. 递归函数的函数名
// 3. 递归函数的形参列表
// 4. 递归函数的函数体：
// 5. 递归函数的结束条件 递归的出口
// 6. 递归函数的递归表达式 自己调用自己